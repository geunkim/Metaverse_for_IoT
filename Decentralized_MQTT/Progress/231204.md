## Pool 접속 및 DID, 공개 키 저장

![image](https://github.com/Hongyoosung/Metaverse_for_IoT/assets/101240036/ffc19bd6-a89e-4520-83d7-2343f6586156)
- 라즈베리파이 디바이스에서 Pool에 접속 및 DID 저장을 성공
- 이후 데이터에 서명을 하고 송신을 하는 모습


<br/>


```python
import RPi.GPIO as GPIO
import time
import paho.mqtt.client as mqtt
from indy import crypto, wallet, did, pool, ledger
import json
import asyncio
import base64

# MQTT 연결 콜백 함수
def on_connect(client, userdata, flags, rc):
    print("Connected with result code " + str(rc))

# MQTT 클라이언트 설정
client = mqtt.Client()
client.on_connect = on_connect
client.connect("192.168.0.23", 1883, 60)
client.loop_start()

# 초음파 센서 설정
GPIO.setmode(GPIO.BCM)
TRIG = 23
ECHO = 24
GPIO.setup(TRIG, GPIO.OUT)
GPIO.setup(ECHO, GPIO.IN)

# 월렛 및 풀 설정
wallet_config = '{"id": "my_wallet20"}'
wallet_credentials = '{"key": "wallet_key"}'
pool_name = "my_poo27"
seed = "issuer10000000000000000000000000"
pool_genesis_txn_path = "/home/user/Desktop/genesis.txn"

# 풀에 연결하는 비동기 함수
async def connect_to_pool():
    await pool.set_protocol_version(2)
    pool_config = json.dumps({"genesis_txn": str(pool_genesis_txn_path)})
    await pool.create_pool_ledger_config(pool_name, pool_config)
    pool_handle = await pool.open_pool_ledger(pool_name, pool_config)
    return pool_handle

# 풀을 닫는 비동기 함수
async def close_pool(pool_handle):
    await pool.close_pool_ledger(pool_handle)

# 월렛을 만들고 DID를 얻는 비동기 함수
async def create_wallet_and_get_did(pool_handle):
    try:
        await wallet.create_wallet(wallet_config, wallet_credentials)
    except:
        print("wallet already created")

    wallet_handle = await wallet.open_wallet(wallet_config, wallet_credentials)

    try:
        steward_did_json = json.dumps({'seed':seed})
        (steward_did, steward_verkey) = await did.create_and_store_my_did(wallet_handle, steward_did_json)
    except:
        print("steward DID already exists")

    print(steward_did)

    try:
        (user_did, user_verkey) = await did.create_and_store_my_did(wallet_handle, "{}")
    except:
        print("user DID already exists")

    print(user_did)

    nym_request = await ledger.build_nym_request(steward_did, user_did, user_verkey, None, None)
    await ledger.sign_and_submit_request(pool_handle, wallet_handle, steward_did, nym_request)
    print("OK!!")

    return wallet_handle, steward_did

# 월렛을 사용하여 데이터에 서명하는 비동기 함수
async def sign_data(wallet_handle, steward_did, data):
    signer_key = await did.key_for_local_did(wallet_handle, steward_did)
    signature = await crypto.crypto_sign(wallet_handle, signer_key, data.encode())
    return base64.b64encode(signature)

# 주요 비동기 함수
async def main():
    # 풀에 연결
    pool_handle = await connect_to_pool()

    # 월렛 만들고 DID 설정
    wallet_handle, steward_did_info = await create_wallet_and_get_did(pool_handle)
    print("wallet_handle : ", wallet_handle)
    print("steward_did_info : ", steward_did_info)

    try:
        for _ in range(5):  # 5번 반복
            GPIO.output(TRIG, False)
            time.sleep(2)

            GPIO.output(TRIG, True)
            time.sleep(0.00001)
            GPIO.output(TRIG, False)

            while GPIO.input(ECHO) == 0:
                pulse_start = time.time()

            while GPIO.input(ECHO) == 1:
                pulse_end = time.time()

            pulse_duration = pulse_end - pulse_start
            distance = round(pulse_duration * 17150, 2)
            print(distance)

            # 데이터에 서명
            signature = await sign_data(wallet_handle, steward_did_info, str(distance))

            # 서명과 데이터를 함께 publish
            payload = {"distance": distance, "signature": signature.decode(), "did":steward_did_info}
            client.publish("myTopic1", json.dumps(payload))
            print(json.dumps(payload))

            time.sleep(3)
    finally:
        if wallet_handle is not None:
            # 프로그램 종료 시에 정리 작업 수행
            await wallet.close_wallet(wallet_handle)
        # 풀 연결 닫기
        await close_pool(pool_handle)

try:
    asyncio.get_event_loop().run_until_complete(main())
except KeyboardInterrupt:
    pass
finally:
    # 프로그램 종료 시에 정리 작업 수행
    client.loop_stop()
    GPIO.cleanup()
```
